package lec3;
/**
 * @author floka
 */
public class Lec3 {
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        double x = 15.7;
        //явное приведение типов
        int y = (int) 15.7;
        long y1 = Math.round(15.7);

        System.out.println("x=" + x); //x = 15.7
        System.out.println("y=" + y); //y = 15 на 16 просто
        // отбрасывается дробная часть
        System.out.println("y1=" + y1); //y = 16 округляется правильно
        //Неявное приведение типов: ("x=" + x)
        /*При неявном приведении типов
        если в выражении участвуют операнды разных типов
        , то результат приводится к тому типу, который занимает больше
        места в памяти.*/
        byte a = 2;
        a = (byte) (a * 5);
        System.out.println("a=" + a); //a = 10 нормально
        a = 2;
        a = (byte) (a * 130);
        System.out.println("a=" + a); //a = 4 остались только последние
        // 8 бит
        System.out.println(Integer.toBinaryString(a));      //100
        System.out.println(Integer.toBinaryString(2 * 130));
        //100000100

        /*Арифметические операторы
        К арифметическим операторам относятся:
        сложение (+),
        вычитание (-),
        умножение (*),
        деление (/),
        вычисление остатка (%),
        инкремент (++),
        декремент (--) */
        System.out.println(18 / 4); //4 остаток от целочисленного
        // деления отбрасывается
        System.out.println(18.0 / 4); //4.5 преобразуется в double
        // неявно
        System.out.println((double) 18 / 4); //4.5 преобразуется в
        // double явно
        System.out.println(18 % 4); //Остаток от целочисленного
        // деления = 2
        int i = 5;
        System.out.println(i++); //Здесь 5 т.к. это постфиксный
        // инкремент
        System.out.println(i);   //Здесь 6 от предыдущей строки
        i = 5;
        System.out.println(++i); //Здесь 6 т.к. это префиксный инкремент
        System.out.println(i);   //Здесь 6 от предыдущей строки

        /*Логические операторы
        Логическое И (&) - результатом выражения A&B является true,
        если оба операнда имеют значение true.
        Если хотя бы один из операндов имеет значение false,
        то результатом является false. */
        boolean lt = true;
        boolean lt1 = true;
        boolean lf = false;
        boolean lf1 = false;
        System.out.println(lt & lt1); //true
        System.out.println(lt && lf);  //false
        /* Укороченное логическое И (&&) - выражение A&&B вычисляется
        точно так же,
        как A&B, но если при проверке операнда A оказывается, что оно
        равно false,
        то значение B уже не проверяется, а сразу возвращается значение
        false.

        Логическое ИЛИ (|) - результатом выражения A|B является true,
        если значение хотя бы одного из операндов является true.
        В ином случае возвращается значение false.
        Укороченное логическое ИЛИ (||) - результат выражения A||B
        совпадает с результатом A|B, но если при проверке операнда
        A оказывается, что он имеет значение true,
        то второй операнд не проверяется, и сразу возвращается значение
        true.*/
        System.out.println(lt | lt1); //true
        System.out.println(lt || lf); //true
        System.out.println(lf || lf1); //false

        /*Логическое исключающее ИЛИ (^) - результатом выражения A^B
        является true,
        если один операнд имеет значение true, а другой имеет значение
        false.
        Если оба операнда одновременно имеют значение true,
        или оба операнда одновременно имеют значение false,
        то возвращается значение false. (Сумматор по модулю 2)*/
        System.out.println(lt ^ lt1); //false
        System.out.println(lt ^ lf); //true
        System.out.println(lf ^ lf1); //false
        /*Унарное логическое отрицание (!) - результатом выражения
        ! A является false, если операнд имеет значение true, и
         наоборот.*/

        /*При помощи логических операторов можно формировать сложные
        выражения
        с участием нескольких операндов, например:
        A & B & C - это выражение возвращает значение true,
        только если все три операнда одновременно имеют значение true.
        A | B | C - это выражение возвращает true,
        если хотя бы один из операндов имеет значение true.

        A&B|C - это выражение возвращает true, если A и B одновременно
        имеют значение true, или C имеет значение true.
        Оператор & имеет более высокий приоритет, поэтому сначала
        вычисляется значение выражения A&B,
        и результат вступает в логическую операцию ИЛИ c операндом C. */
        System.out.println(lt & lt1 | lf); //true
        System.out.println(lt | lf | lf1); //true
        System.out.println(lt & lt1 & lf); //false

        /* Битовые операторы
        Битовые (или побитовые) операторы предназначены для операций с
        целыми
        числами на уровне их побитового представления.
        Битовое И (&) - выражение A&B выполняется побитово,
        т.е. отдельно для каждого разряда. Если оба бита единичные,
        то в соответствующем разряде результата будет единица.
        Если хотя бы один из битов нулевой, в разряд результата
        записывается ноль.
        Пример: 1101 & 0110 = 0100 */
        System.out.println(Integer.toBinaryString(0b1101 & 0b0110));
        // 100

        /*Битовое ИЛИ (|) - выражение A|B выполняется побитово. Если
        хотя бы один
        из битов единичный, то в соответствующий разряд результата будет
        записана единица.
        Если оба бита нулевые, то в разряд результата будет записан
        ноль.
        Пример: 1101| 0110 = 1111*/
        System.out.println(Integer.toBinaryString(0b1101 | 0b0110));
        // 1111
        /*Битовое исключающее ИЛИ (^) - выражение А^В выполняется
        побитово.
        Если один из сравниваемых битов нулевой, а другой единичный,
        то в разряд результата записывается единица. Если оба бита
        нулевые, или оба бита единичные,
        то в разряд результата записывается ноль.
        Пример: 1101 л 0110 = 1011*/
        System.out.println(Integer.toBinaryString(0b1101 ^ 0b0110));
        // 1011
        /*Битовый сдвиг вправо (>>) - результатом выполнения оператора
        А>> n
        является число, которое получилось сдвигом двоичного числа A
        вправо на n позиций.
        При сдвиге сохраняется знак числа, то есть младшие разряды
        теряются,
        а старшие заполняются содержимым знакового бита
        (0 для положительных чисел и 1 для отрицательных).
        Примеры: отрицательное число int 4 байта*/
        System.out.println(0b10000000000000000000000011010010);
        //-2147483438 большое отрицательное int
        System.out.println(Integer.toBinaryString
                ((0b10000000000000000000000011010010)>> 2));
        System.out.println(Integer.toBinaryString((-2147483438)>> 2));
        //11100000000000000000000000110100
        System.out.println(Integer.toBinaryString((0b00010100)>> 2));
        //101
        /*Беззнаковый битовый сдвиг вправо (>>>) - результатом
        выполнения оператора А>>> n
        является число, которое получилось сдвигом двоичного числа A
        вправо на n позиций.
        При сдвиге НЕ сохраняется знак числа, то есть младшие разряды
        теряются,
        а старшие заполняются нулями.*/
        System.out.println(Integer.toBinaryString((-2147483438)>>> 2));
        //00100000000000000000000000110100
        /*Битовый сдвиг влево (<<) - результатом выполнения
         оператора A <<n
        является число, которое получилось сдвигом двоичного числа А
        влево на n позиций.
        При этом старшие разряды теряются, а младшие дополняются
        нулями.*/
        System.out.println(Integer.toBinaryString((-2147483438)<< 2));
        //1101001000 знак - (1 в старшем разряде выталкивается)

        /*Операторы сравнения
        Если условие, заданное оператором сравнения, выполняется,
        то выражение возвращает значение true.
        В противном случае возвращается значение false.
        Все операторы сравнения бинарные - содержат только два операнда.
        Равно (==) - выражение A==B возвращает true,
        если значение операнда А равно значению операнда B.
        Обратите внимание, оператор сравнения состоит из двух знаков
        равенства.
        Если вы используете одиночный знак равенства, то получится не
        сравнение,
        а присвоение значения.
        Не равно (!=) - выражение А!=В возвращает true, если значение
        операнда А
        отлично от значения операнда B.
        Больше (>) - выражение А> B возвращает true, если значение
        операнда А
        больше значения операнда B.
        Больше или равно (> =) - выражение А> =B возвращает true, если
        значение
        операнда А больше или равно значению операнда B.
        Меньше (<) - выражение А <В возвращает true, если значение
        операнда А
        меньше значения операнда B.
        Меньше или равно (<=) - выражение А <=B возвращает true, если
        значение
        операнда А меньше или равно значению операнда B.*/
        int z=2,z1=3;
        System.out.println(z>z1); //false
        System.out.println(z<z1); //true

        /*Тернарный оператор
        В языке Java имеется единственный оператор, у которого три
        операнда.
        Этот оператор обозначается символом вопроса (?) и имеет
        следующий синтаксис:
        условие? значение: значение
        Условием является выражение с логическим значением.
        Сначала вычисляется значение выражения, указанного в условии.
        Если оно истинное, то оператор возвращает значение,
        расположенное после вопросительного знака.
        Если значение условия ложное, то оператор возвращает значение,
        следующее после двоеточия.
        Например:*/
        z=10;
        z1 = (z > 5)? 50: 60;
        System.out.println(z1); //50
        /*В данном случае переменной b будет присвоено значение 50.
        Тернарный оператор представляет собой сокращенную форму
        условного оператора
        Еще называют условие в строку*/
    }
}
